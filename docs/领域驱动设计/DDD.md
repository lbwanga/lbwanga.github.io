[DDD领域驱动设计理论｜得物技术领域驱动设计简称“DDD”，一套“知易行难”的方法论。同时我所工作的这些年，尤其在某大厂 - 掘金](https://juejin.cn/post/7371716397297139721?searchId=202503022149398C5C811F3D881B18269B)

## DDD是什么？

DDD 是一种软件设计方法。

DDD设计的目标是实现软件系统与业务需求的高度契合，提高开发效率和质量，同时也能更好地应对复杂性和变化性。它强调以业务为中心，通过深入领域知识和建立有效的领域模型，来驱动软件设计和开发的整个过程。

领域驱动设计是为了解决复杂软件设计的一种优秀方案，它把所有的业务规则、定义、范围、知识等抽象成了一个大的概念，叫做**领域**。比如用户支付的业务场景，叫做交易域；平台提供售后等服务叫做服务域（或客服域），还有其他诸如金融域，人效域，物流域等。它应对复杂性的思想，总结下来既简单，又精炼，叫做“**分而治之**”。把最大化的领域（复杂问题）分为下层的一个个子域，同时每个子域又规定好边界和核心实体，通过一系列的拆分、归类、衍生，最终找到最优解。



> **DDD vs MVC**

MVC架构其实很精粹，清晰，对于业务逻辑并不复杂，单一化的场景其实效率是很高的。但是随着业务的多变性和不断复杂化，MVC架构就会暴露以下问题：

1. MVC架构没有边界划分的概念和规范，在复杂的业务场景下会造成盘根交错的逻辑依赖，同时随着业务场景的不复杂化，代码意图会逐渐模糊，维护成本增加，对于系统的稳定性也会带来挑战。
2. MVC**仅反映软件架构的分层，不定义业务语义的抽象和表达**，对于业务知识的沉淀和复用性来说，不太友好。
3. MVC分割了数据和行为的表达，Model层（pojo）定义数据，Service层表述行为，会造成业务逻辑的首尾分离。



> **DDD的价值**

团队价值：

1. 统一语言
2. 清晰的边界定义：定义清晰的业务范围，避免边界纷争。
3. 面向业务建模
4. 代码直观表现设计

个人价值：

1. 提升全局视野
2. 提升业务sense



> **DDD的缺点**

1. 逻辑相对简单的业务和产品，用传统的MVC架构会更适合，构建也更快速。

2. 非业务形态产品和应用并不适合，比如bigdata。这类应用和业务专注于数据层的交互和适配，并无强业务语义类诉求，而DDD最关键的一部分就是业务领域的抽象和包装，切记，它解决的是负责业务问题。



> **DDD 的核心原则包括**

- **领域为中心**：以业务领域为核心，所有设计围绕领域模型展开。
- **通用语言**：开发团队与领域专家共同定义一套无歧义的术语，贯穿设计、代码和文档。
- **分层架构**：分离技术实现与业务逻辑，典型分层包括用户界面层、应用层（协调用例）、领域层（核心业务规则）、基础设施层（技术实现）。
- **战略设计**：通过限界上下文（Bounded Context）划分领域边界，明确上下文映射关系（如防腐层、共享内核等）。
- **战术设计**：使用领域模型元素（实体、值对象、聚合、领域服务、领域事件等）实现业务逻辑。
- **持续演进**：模型随业务需求迭代，通过重构保持灵活性。



## 核心概念

DDD这套方法论的一个完整设计流程：核心在于战略设计和战术设计

![](./DDD/DDD完整设计流程.png)

1. 首先第一步，根据业务诉求，**提炼出整体的业务流程**，同时拆解出里面的关键事件，角色，参与者等核心实例。整个拆解和梳理的方法论，目前业界有一些比较成熟的，比如事件风暴，四色建模法等。

2. 提炼完整个业务流程后，进入战略设计阶段，这个阶段主要是从全局和顶层的视角，**把整个业务语义转换为结构化分层**。通过领域和子域的划分，同时结合通用域、支撑域、限界上下文等设计，分解问题复杂度，其实就是前面说到的“分而治之”的思想。

3. 接下来就会到具体的战术设计阶段，通过前面的战略设计阶段，已经把整个领域、边界、上下文等关键模块都梳理完成，现在就是**从各个域中再次拆解更细粒度的模块**，去指导最终的编码实现，这些更细粒度的模块包括实体、聚合、聚合根等。

4. 最后就到了编码实现阶段，DDD有一个关键价值，叫做 **“设计即实现”** ，所以在战术阶段的设计，理论上是可以直接作用于代码的分层结构，如果架构和战术阶段有出入，说明之前的设计有问题，可以复盘重新推演。



**战略设计**

战略设计关注的是在整个业务和系统架构层面上进行设计，主要涉及如何识别、划分和组织领域。其重点是理解业务环境、领域边界、子领域和这些子领域之间的关系。它通常在项目前期的需求分析阶段应用，帮助团队成员达成对业务的共识。

**战术设计**

战术设计关注的是具体的技术实现层面，涉及到如何在每个界限上下文内具体实现领域模型。它包括设计实体、值对象、聚合、领域服务等。它在战略设计完成后的详细设计和开发阶段应用。

> **战略设计**主要解决的是“什么”的问题：我们在做什么，业务的哪些部分需要关注，以及如何划分边界。
>
> **战术设计**则关注“怎么做”：在这些领域中，我们如何具体实现领域模型和功能。

**领域**

领域（Domain）是指业务问题的特定领域范围，它涉及到特定业务的规则、概念、业务流程等。领域是对业务问题进行分解和组织的基本单位。

**通用语言**

通用语言是领域驱动设计中团队成员（业务人员、开发人员、测试人员等）在交流和协作时使用的统一、无歧义的语言，基于业务领域概念和规则构建。使用通用语言能消除沟通障碍，确保团队对业务需求理解一致，提升协作效率和质量。

**子域**

子域（Subdomain）是指在一个大的领域中划分出的相对独立的子领域，它通常代表一个独立的业务领域，具有特定的业务逻辑和功能需求。子域可以是整个系统的一个功能模块，也可以是一个独立的业务流程。

**通用域**

通用域（Generic Domain）是指与特定业务领域无关的通用功能，它是在整个领域中被多个子域所共享和复用的功能。通用域包括一些通用的服务、工具、组件等，用于支持多个子域的实现。

**支撑域**

支撑域（Supporting Domain）指的是与核心业务的实现和发展密切相关的非业务功能。这些支撑域可以包括安全认证、用户管理、日志记录等在整个系统中被多个子域所共享和使用的基础设施功能。支撑域和通用域概念上有些类似，区分他们的标准简单归纳下的话，支撑域是由外域提供的能力，通用域是本域提供。

**限界上下文**

限界上下文是领域模型中一个明确的边界，边界内的模型术语、规则和逻辑保持一致，且独立于其他上下文。



**实体**

实体是具有唯一标识的对象，其标识在对象的整个生命周期内保持不变。实体的状态可以改变，但标识不变，通过标识可以跟踪实体的变化。

1. **贫血模型**：贫血模型指的是实体主要包含属性（字段）而缺乏业务逻辑和行为。业务逻辑通常被放置在服务（Service）层中。
2. **充血模型**：充血模型与贫血模型相反，实体不仅包含数据，还包含处理这些数据的业务逻辑。实体通常会有丰富的方法来操作其内部状态。

> 更喜欢使用**贫血+充血的混合模型**（或者叫充血模型的简化版），因为这里涉及到一个标准的建立问题，如果只用充血模型的话，哪些行为和逻辑该下方到接口服务层，哪些又该收拢到实体中，这里面每个人的理念不一样。而我的标准是，**涉及到持久层和复杂行为都下放到服务层，简单行为放到实体模型中**。这样有个好处，随着业务的发展，如果只用充血模型，你的实体会越来越臃肿；如果只有贫血模型，自身又太单薄。所以一部分行为下放到服务层，我可以更细粒度的拆分服务接口，保证更优良的边界和代码可读性，同时也保证了模型自身的健壮性。

**值对象**

值对象没有唯一标识，它描述的是一个不变的概念整体，主要通过属性值来进行区分和比较。值对象一旦创建，其属性值通常不会改变。比如地址信息，手机号码，标签属性等。

**聚合**

聚合是一组相关对象的集合，这些对象在某种业务上是紧密相关的，并且在某些操作中需要作为一个整体来处理。聚合确保了该集合内部的业务规则和不变量的一致性。通常，聚合包含多个实体（Entity）和值对象（Value Object），它们共同代表一个一致的概念。

**聚合根**

聚合根是聚合中唯一的入口点，它是聚合的代表，并且负责管理聚合内部的其他对象。任何外部对象对聚合的访问只能通过聚合根进行。聚合根确保了聚合内一致性和完整性，保证通过聚合根进行的所有操作都不会违反业务规则。

**仓储**

用于封装数据访问逻辑，使应用程序能够以面向对象的方式处理持久性数据，提供了持久化和查询操作。仓库将领域模型与数据存储层分离，使得领域模型可以专注于业务逻辑。

**领域模型**

领域模型是对业务领域的抽象，旨在捕捉业务需求和规则。它通常包括实体、值对象和聚合。

**领域服务**

用于表示在业务领域中，无法归类为实体或值对象的操作。领域服务允许将业务逻辑与数据模型分离。用途主要包括处理跨多个实体的业务逻辑、封装复杂业务规则以及处理与外部系统的交互。

**领域事件**

代表领域中的发生的重要事件，可以用于通知其他领域对象或跨限界上下文进行解耦和协作。



## 领域建模

**事件风暴建模**

事件风暴通过团队协作的方式，以用户的视角来讨论和探索整个业务流程。参与者将自己的理解和知识通过贴在墙上的便利贴上表达出来，核心会围绕着事件去编排整个业务流程。

先从业务事件入手，找出引发这些事件的命令，进而确定产生这些命令的聚合根。例如在电商系统中，“订单创建”是一个事件，对应的命令可能是“用户提交订单”，相关的聚合根可能是“订单”。

**四色建模**

四色建模，基于业务角色和时间维度，将元素分为时刻/时间段、角色、描述、事实四类进行建模。用一句话来概括四色原型就是：**一个什么样的人或物品以某种角色在某个时刻或某段时间内参与某个活动**。



DDD 的建模过程，是以一个用户为起点，通过行为命令，发起行为动作，串联整个业务。而这个用户的起点最初来自于用例图的分析。用例图是用户与系统交互的最简表示形式，展现了用户和与他相关的用例之间的关系。通过用例图，我们可以分析出所有的行为动作。

在 DDD 中用于完成用户的行为命令和动作分析的过程，是一个四色建模的过程，也称作风暴模型。

![](./DDD/建模方法.png)

通过寻找领域事件，发起事件命令，完成领域事件的过程，完成 DDD 工程建模。

- 蓝色 - 决策命令，是用户发起的行为动作，如：开始签到、开始抽奖、查看额度等。
- 黄色 - 领域事件，过去时态描述。如：签到完成、抽奖完成、奖品发放完成。它所阐述的都是这个领域要完成的终态。
- 粉色 - 外部系统，如你的系统需要调用外部的接口完成流程。
- 红色 - 业务流程，用于串联决策命令到领域事件，所实现的业务流程。一些简单的场景则直接由决策命令到领域事件就可以了。
- 绿色 - 只读模型，做一些读取数据的动作，没有写库的操作。
- 棕色 - 领域对象，每个决策命令的发起，都是含有一个对应的领域对象。



## 分层架构

![](./DDD/工程结构.png)

- **接口定义 - api**：因为微服务中引用的 RPC 需要对外提供接口的描述信息，也就是调用方在使用的时候，需要引入 Jar 包，让调用方好能依赖接口的定义做代理。
- **应用封装 - app**：这是应用启动和配置的一层，如一些 aop 切面或者 config 配置，以及打包镜像都是在这一层处理。你可以把它理解为专门为了启动服务而存在的。
- **领域封装 - domain**：包含业务逻辑和领域模型，负责处理与业务相关的规则和行为。领域层是DDD的核心，包含实体（Entities）、值对象（Value Objects）、聚合（Aggregates）和领域服务（Domain Services）。
- **仓储服务 - infrastructure**：提供技术支撑，如持久化机制、外部服务的调用、消息队列等。基础设施层与其他层进行通信，负责平台相关的细节和实现。基础层依赖于 domain 领域层，因为在 domain 层定义了仓储接口需要在基础层实现，这是依赖倒置的一种设计方式。
- **领域封装 - trigger**：触发器层，一般也被叫做 adapter 适配器层。负责与用户交互，接收用户输入并展示输出。通常包括用户界面（UI）和应用程序编程接口（API）。
- **类型定义 - types**：通用类型定义层，在我们的系统开发中，会有很多类型的定义，包括；基本的 Response、Constants 和枚举。它会被其他的层进行引用使用。
- **领域编排【可选】 - case**：领域编排层，一般对于较大且复杂的的项目，为了更好的防腐和提供通用的服务，一般会添加 case/application 层，用于对 domain 领域的逻辑进行封装组合处理。

