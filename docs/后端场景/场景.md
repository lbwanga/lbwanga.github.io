## 一笔用户订单，在取消的那一刻刚好付款怎么办？

会出现两种情况：

1. 支付成功，回调那一刻还没取消：则取消执行失败，不做任何处理。
2. 支付成功，回调那一刻已取消：退款

解决方法：基于原始状态判断

```sql
# 支付成功
update pay_info set status = 'paySuccess' where orderId='1' and status = 'paying';
# 取消
update pay_info set status = 'cancel' where orderId='1' and status = 'paying';
```



除了利用数据库处理，还可以使用分布式锁。

订单取消流程：

1. 超时触发取消订单
2. 取消订单方法中先获取该订单的分布式锁，如果锁被其他操作持有（如付款），等待或抛出异常。获取锁成功，则检查订单状态是否已付款：
   1. 未付款：更新订单状态为已取消。
   2. 已付款：直接跳过该订单的处理
3. 释放分布式锁。



订单付款流程：

1. 三方支付成功回调
2. 后端系统接收回调后，先获取该订单的分布式锁，如果锁被其他操作持有（如取消），等待或者抛出异常（没有给三方响应成功，三方会重新发起回调）。成功获取锁，检查订单状态是否为待支付：
   1. 待支付：继续执行扣款，更新订单状态为已支付
   2. 已取消：发起退款，提示用户订单取消
3. 释放分布式锁。



## 如何避免重复下单？

1）每次下单请求中生成一个唯一的requestId或token。

进入订单页面时会先向后端请求生成一个唯一的requestId或token，每次下单请求携带该requestId或token。

2）分布式锁 ：以用户维度加上分布式锁。



## 线上消息队列故障，兜底改造方案

1）RocketMQ事务消息，但是侵入性比较大，需要修改接口适配事务消息的实现。

2）本地消息表



### RocketMQ事务消息

基于MQ的事务消息方案主要依靠MQ的**半消息机制**来实现投递消息和参与者自身本地事务的一致性保障。

![](./后端场景/事务消息.png)



### 本地消息表

![](./后端场景/本地消息表.png)

**0. 创建本地消息表：**

在数据库中创建一个本地消息表，用于存储待发送的消息以及消息的发送状态和相关信息。表结构可以包含字段如下：

- `message_id`：消息的唯一标识。
- `message_body`：消息内容。
- `status`：消息状态，如待发送、已发送等。
- `create_time`：消息创建时间。
- 其他字段，如重试次数、发送时间等。

**1. 业务处理：** 业务处理时通常进行db变更

**2. 将记录消息插入记录表**：在业务逻辑中，当需要发送消息时，首先将消息插入到本地消息表中，设置状态为待发送。1、2步骤在同一个本地事务中。业务数据和消息表在同一个数据库，要保证它俩在同一个本地事务。直接利用本地事务，将业务数据和事务消息直接写入数据库。

**3. 发送消息**

**3.1,3.2. 消息补偿机制：**

单独创建一个后台线程或定时任务，定时扫描本地消息表中状态为待发送的消息，并将这些消息发送到消息队列。在成功发送到消息队列后，将消息表中对应的状态修改为已发送。此外，可以根据需要实现消息发送失败后的重试机制。

**4. B系统消费消息：**消费者监听消息队列，解析消息内容。

**5. B系统进行业务逻辑处理：**进行业务逻辑处理，更改DB。**此步骤必须要保证幂等性**。

**6. 确认消费完成：**当消息消费完成后，调用A系统进行状态变更

**6、7如果失败相当于两个分布式系统的数据已经一致了，但是本地消息表的状态还是错的。这种情况下借助`3.1、3.2`的重新投放策略，让下游幂等处理再更改消息表的状态也能解决。或者A系统也可以查询B系统的处理状态，如果成功直接更改状态**。

![](./后端场景/本地消息表序列图.png)

需要注意以下几点：

- **消息的幂等性：** 消费者一定需要保证接口的幂等性，消息的幂等性非常重要，以防止消息重复处理导致的数据不一致。
- **本地消息表的设计：** 本地消息表的设计需要考虑到消息状态、重试次数、创建时间等字段，以便实现消息的跟踪和管理。
- **定时任务和重试机制：** 需要实现定时任务或者重试机制来确保消息的可靠发送和处理。



优点：

- 本地消息表建设成本比较低，实现了可靠消息的传递确保了分布式事务的最终一致性。
- 无需提供回查方法，进一步减少的业务的侵入。
- 在某些场景下，还可以进一步利用注解等形式进行解耦，有可能实现无业务代码侵入式的实现。

缺点：

- 本地消息表与业务耦合在一起，难于做成通用性，不可独立伸缩。
- 本地消息表是基于数据库来做的，而数据库是要读写磁盘IO的，因此在高并发下是有性能瓶颈的
- 数据大时，消息积压问题，扫表效率慢
- 数据大时，事务表数据爆炸，定时扫表存在延迟问题



**本地消息表实现分布式事务缺点及解决方式**：

消息堆积、扫表效率慢：

- 索引优化：在消息表中对状态字段增加索引，以加速扫表操作。索引可以加速消息的检索和筛选，从而提高操作效率。
- 分页查询：将扫表操作划分为多次分页查询，避免一次性查询大量数据造成的性能问题。
- 表较大时进行分库分表：如果表较大可以进行分库分表操作。
- 多线程分段查询：
  - 如果有业务标识，可以通过业务标识进行多线程分段扫表查询。
  - 如果没有业务标识可以按区间查询比如线程1查询0-1000的数据，线程2查询1001-2000的数据。

定时任务扫表延迟问题：

定时任务可能由于各种原因导致扫表延迟，进而影响事务处理的实时性。以下是一些应对方法：

- 异步发送MQ改为同步调用接口：异步改为同步调用B系统接口，如果失败了再进行异步发送MQ消息。
- 发送MQ延迟消息，去掉定时任务，避免大量扫表处理。
- 分布式定时任务： 使用分布式定时任务框架，将定时任务分散到多个节点上执行，以减少单个节点的压力，同时提高定时任务的稳定性和准确性。
- 增加资源： 增加定时任务执行节点的数量，以提高并发处理能力，减少延迟。

